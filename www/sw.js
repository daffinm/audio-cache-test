// =====================================================================================================================
// WARNING: this file was generated. Edit ./www-src/sw.js and then run ./build to regenerate in ./www-deploy dir.
// =====================================================================================================================

function swlog(message, object) {
    console.log(`[Service Worker] ${message}`, object ? object : '');
}
// Update with latest Workbox 4 and 5 versions. See https://github.com/GoogleChrome/workbox/releases
const WorkboxVersions = Object.freeze({
    V4: "4.3.1",
    V5: "5.0.0-beta.0"
});
const WORKBOX_DEBUG = true;
// Switch Workbox Versions here.
const WORKBOX_VERSION = WorkboxVersions.V4;
const APP_CACHE_PREFIX = 'act';
const APP_CACHE_VERSION = 'actv0.0.1';
const APP_CACHE_SUFFIX = `wbv${WORKBOX_VERSION}-${APP_CACHE_VERSION}`;
importScripts(`https://storage.googleapis.com/workbox-cdn/releases/${WORKBOX_VERSION}/workbox-sw.js`);
if (workbox) {
    swlog(`Yay! Workbox ${WORKBOX_VERSION} is loaded ðŸ˜`);
} else {
    swlog(`Boo! Workbox ${WORKBOX_VERSION} didn't load ðŸ˜¬`);
}
workbox.setConfig({debug: WORKBOX_DEBUG});
workbox.core.setCacheNameDetails({
    prefix: APP_CACHE_PREFIX,
    suffix: APP_CACHE_SUFFIX,
    precache: 'auto-pre-cache',
    runtime: 'runtime-cache',
});
// Clean up old cache - ones that we know are ours and that we will never use again.
// TODO check namespace logic. Do I really need to check the prefix or will I only ever be dealing with caches for my app because of namespace segregation?
self.addEventListener('activate', function(event) {
    event.waitUntil(
        caches
            .keys()
            .then(keys => keys.filter(key => key.startsWith(APP_CACHE_PREFIX) && !key.endsWith(APP_CACHE_SUFFIX)))
            .then(keys => Promise.all(keys.map(key => caches.delete(key))))
    );
});

// The plugins we are going to need
let precachePlugins = [];
let manualCachePlugins = [];
if (WORKBOX_VERSION === WorkboxVersions.V4) {
    precachePlugins = [
        new workbox.rangeRequests.Plugin()
    ];
    manualCachePlugins = [
        new workbox.cacheableResponse.Plugin({statuses: [200]}),
        new workbox.rangeRequests.Plugin(),
    ];
} else {
    precachePlugins = [
        new workbox.rangeRequests.RangeRequestsPlugin()
    ];
    manualCachePlugins = [
        new workbox.cacheableResponse.CacheableResponsePlugin({statuses: [200]}),
        new workbox.rangeRequests.RangeRequestsPlugin(),
    ];
}
// =====================================================================================================================
// 1. Precached Audio File
// =====================================================================================================================
// "If you plan on precaching the media files, then you need to take an extra step to explicitly route things so that
// they're read from the precache, since the standard precache response handler won't use the range request plugins"
workbox.routing.registerRoute(
    /.*auto-pre-cached\.(m4a|mp3|mp4)/,
    new workbox.strategies.CacheOnly({
        cacheName: workbox.core.cacheNames.precache,
        plugins: precachePlugins,
        // This is needed since precached resources may
        // have a ?_WB_REVISION=... URL param.
        matchOptions: {
            ignoreSearch: true,
        }
    }),
);
// Precache...
workbox.precaching.precacheAndRoute([]);

// ====================================================================================================================
// 2. Manually Cached Audio File
// =====================================================================================================================
const MANUAL_CACHE_NAME = workbox.core.cacheNames.prefix + '-manual-pre-cache-' +workbox.core.cacheNames.suffix;
// This route will go against the network if there isn't a cache match,
// but it won't populate the cache at runtime.
// If there is a cache match, then it will properly serve partial responses.
workbox.routing.registerRoute(
    /.*manually-pre-cached\.(m4a|mp3|mp4)/,
    // NOTE: using CacheFirst here tricked me into thinking that audio caching was working. But it was failing and going to the network instead...
    // new workbox.strategies.CacheFirst({
    new workbox.strategies.CacheOnly({
        cacheName: MANUAL_CACHE_NAME,
        plugins: manualCachePlugins,
    }),
);
// It's up to you to either precache or explicitly call cache.add('movie.mp4')
// to populate the cache.
caches.open(MANUAL_CACHE_NAME)
    .then(function(cache) {
        cache.add('/media/audio/manually-pre-cached.m4a');
        cache.add('/media/audio/manually-pre-cached.mp3');
        cache.add('/media/video/manually-pre-cached.mp4');
    })
    .catch(function (error) {
        swlog('Error populating audio cache manually:', error);
    });

