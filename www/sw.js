// =====================================================================================================================
// WARNING: this file was generated. Edit ./www-src/sw.js and then run ./build to regenerate in ./www-deploy dir.
// =====================================================================================================================
const BUILD_MMR = '1.0.0';
const BUILD_DATE = '20200328';
const BUILD_NUMBER = '14';
const APP_VERSION = `${BUILD_MMR}.${BUILD_DATE}#${BUILD_NUMBER}`;

importScripts('/js/debug.js');
setDebug(true, `[${APP_VERSION}] {{Service Worker}}:`, '>>');
debug.section(`SERVICE WORKER STARTING >> Version ${APP_VERSION}`);

const WORKBOX_DEBUG = false;
const WORKBOX_VERSION = '5.1.1';
const APP_CACHE_PREFIX = 'mct';
const APP_CACHE_SUFFIX = `v1.0.0`;
importScripts(`https://storage.googleapis.com/workbox-cdn/releases/${WORKBOX_VERSION}/workbox-sw.js`);
if (workbox) {
    debug.log(`Yay! Workbox ${WORKBOX_VERSION} is loaded ðŸ˜`);
} else {
    throw new Error(`Boo! Workbox ${WORKBOX_VERSION} didn't load ðŸ˜¬`)
}
workbox.setConfig({debug: WORKBOX_DEBUG});
workbox.core.setCacheNameDetails({
    prefix: APP_CACHE_PREFIX,
    suffix: APP_CACHE_SUFFIX,
    precache: 'installtime',
    runtime: 'runtime',
});
const MEDIA_CACHE_NAME = `${APP_CACHE_PREFIX}-runtime-media-${APP_CACHE_SUFFIX}`;
// ---------------------------------------------------------------------------------------------------------------------
// So the clients can tell us when to update.
// ---------------------------------------------------------------------------------------------------------------------
self.addEventListener('message', (event) => {
    if (event.data && event.data.message) {
        debug.log(`>>> Message received from client: `, event.data);
        if (event.data.message === 'SKIP_WAITING') {
            self.skipWaiting();
        } else if (event.data.message === 'CLIENTS_CLAIM') {
            self.clients.claim();
        } else {
            debug.warning('>>>> No idea what to do with that message!');
        }
    } else {
        throw new Error(`Message event handler: event.data=[${event.data}], event.data.message=[${event.data.message}]`);
    }
});
//======================================================================================================================
// Caching
//======================================================================================================================
function deleteOldCaches(activationEvent) {
    activationEvent.waitUntil(
        caches
            .keys()
            .then(keys => keys.filter(key => key.startsWith(APP_CACHE_PREFIX) && !key.endsWith(APP_CACHE_SUFFIX)))
            .then(keys => Promise.all(keys.map(key => caches.delete(key))))
    );
}
self.addEventListener('activate', function(event) {
    debug.log(`Lifecycle event: [${event.type}] - ready to handle fetches!`);
    deleteOldCaches(event);
});

// ---------------------------------------------------------------------------------------------------------------------
// Runtime Audio Caching: 'vorsprung durch technik'
// ---------------------------------------------------------------------------------------------------------------------
const mediaRouteMatcher = ({url, event}) => {
    let matches = event.request.url.match(/.*\.(mp3|m4a|mp4)$/);
    return matches;
};
// This file constains the stuff we need to do runtime media caching.
importScripts('/js/workbox-utils.js');
// Leverage Workbox injectManifest to give us a list of media files with revision data.
const mediaRouteHandler = new WorkboxCacheFullyThenCacheOnly(
    self,
    MEDIA_CACHE_NAME,
    self._MEDIA_FILES);
// Register the media router.
workbox.routing.registerRoute(
    mediaRouteMatcher,
    mediaRouteHandler
);
// ---------------------------------------------------------------------------------------------------------------------
// Precache.
// ---------------------------------------------------------------------------------------------------------------------
workbox.precaching.cleanupOutdatedCaches();
workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);
