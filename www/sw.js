// =====================================================================================================================
// WARNING: this file was generated. Edit ./www-src/sw.js and then run ./build to regenerate in ./www-deploy dir.
// =====================================================================================================================
const BUILD_MMR = '1.0.0';
const BUILD_DATE = '20200331';
const BUILD_NUMBER = '2';
const APP_VERSION = `${BUILD_MMR}.${BUILD_DATE}#${BUILD_NUMBER}`;

importScripts('/js/debug.js');
const debug = new Debug(true, `[${APP_VERSION}] {{Service Worker}}:`, 'Ş');
debug.heading(`SERVICE WORKER STARTING >> Version ${APP_VERSION}`);

const WORKBOX_DEBUG = true;
const WORKBOX_VERSION = '5.1.1';
const APP_CACHE_PREFIX = 'mct';
const APP_CACHE_SUFFIX = `v1.0.0`;
importScripts(`https://storage.googleapis.com/workbox-cdn/releases/${WORKBOX_VERSION}/workbox-sw.js`);
if (workbox) {
    debug.log(`Yay! Workbox ${WORKBOX_VERSION} is loaded 😁`);
} else {
    throw new Error(`Boo! Workbox ${WORKBOX_VERSION} didn't load 😬`)
}
workbox.setConfig({debug: WORKBOX_DEBUG});
workbox.core.setCacheNameDetails({
    prefix: APP_CACHE_PREFIX,
    suffix: APP_CACHE_SUFFIX,
    precache: 'installtime',
    runtime: 'runtime',
});
// ---------------------------------------------------------------------------------------------------------------------
// So the clients can tell us when to update.
// ---------------------------------------------------------------------------------------------------------------------
self.addEventListener('message', (event) => {
    if (event.data && event.data.message) {
        debug.log(`>>> Message received from client: `, event.data);
        if (event.data.message === 'SKIP_WAITING') {
            self.skipWaiting();
        } else if (event.data.message === 'CLIENTS_CLAIM') {
            self.clients.claim();
        } else {
            debug.warning('>>>> No idea what to do with that message!');
        }
    } else {
        throw new Error(`Message event handler: event.data=[${event.data}], event.data.message=[${event.data.message}]`);
    }
});
//======================================================================================================================
// Caching
//======================================================================================================================
function deleteOldCaches(activationEvent) {
    activationEvent.waitUntil(
        caches
            .keys()
            .then(keys => keys.filter(key => key.startsWith(APP_CACHE_PREFIX) && !key.endsWith(APP_CACHE_SUFFIX)))
            .then(keys => Promise.all(keys.map(key => caches.delete(key))))
    );
}
self.addEventListener('activate', function(event) {
    debug.log(`Lifecycle event: [${event.type}] - ready to handle fetches!`);
    deleteOldCaches(event);
});
// ---------------------------------------------------------------------------------------------------------------------
// Precache:
// ---------------------------------------------------------------------------------------------------------------------
//    Declare here - more efficient since other routes will not be looked at if resource is found in precache.
//    Just the bare bones of the app. Nothing more. Everything else is cached at runtime, the first time it is asked for.
// ---------------------------------------------------------------------------------------------------------------------
workbox.precaching.cleanupOutdatedCaches();
workbox.precaching.precacheAndRoute(self.__PRECACHE_MANIFEST);
// ---------------------------------------------------------------------------------------------------------------------
// Runtime caching (including media): 'vorsprung durch technik'
// ---------------------------------------------------------------------------------------------------------------------
// New strategy:
//    Cache the resource in full the first time it is asked for. Then serve it from the cache only.
//    Update the resource only if the revision information for it has changed.
//    Works for all resources, even media. And seems to give better performance than precaching in Lighthouse.
// ---------------------------------------------------------------------------------------------------------------------
importScripts('/js/workbox-utils.js');
const RUNTIME_CACHE_NAME = `${APP_CACHE_PREFIX}-runtime-${APP_CACHE_SUFFIX}`;
// Create runtime Route.
const runtimeRoute = new WorkboxCacheBeforeCacheOnly(
    self,
    RUNTIME_CACHE_NAME,
    self.__RUNTIME_MANIFEST);
// Register runtime Route.
workbox.routing.registerRoute(
    runtimeRoute.match,
    runtimeRoute
);

