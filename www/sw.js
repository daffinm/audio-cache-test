// =====================================================================================================================
// WARNING: this file was generated. Edit ./www-src/sw.js and then run ./build to regenerate in ./www-deploy dir.
// =====================================================================================================================
const BUILD_MMR = '1.0.0';
const BUILD_DATE = '20200323';
const BUILD_NUMBER = '16';
const APP_VERSION = `${BUILD_MMR}.${BUILD_DATE}#${BUILD_NUMBER}`;

importScripts('/js/debug.js');
setDebug(true, `[${APP_VERSION}] {{Service Worker}}:`, '>>');

const WORKBOX_DEBUG = true;
const WORKBOX_VERSION = '5.1.1';
const APP_CACHE_PREFIX = 'mct';
const APP_CACHE_SUFFIX = `v1.0.0`;
importScripts(`https://storage.googleapis.com/workbox-cdn/releases/${WORKBOX_VERSION}/workbox-sw.js`);
if (workbox) {
    debug.log(`Yay! Workbox ${WORKBOX_VERSION} is loaded 😁`);
} else {
    throw new Error(`Boo! Workbox ${WORKBOX_VERSION} didn't load 😬`)
}
workbox.setConfig({debug: WORKBOX_DEBUG});
workbox.core.setCacheNameDetails({
    prefix: APP_CACHE_PREFIX,
    suffix: APP_CACHE_SUFFIX,
    precache: 'installtime',
    runtime: 'runtime',
});
const MEDIA_CACHE_NAME = `${APP_CACHE_PREFIX}-runtime-media-${APP_CACHE_SUFFIX}`;
// ---------------------------------------------------------------------------------------------------------------------
// So the clients can tell us when to update.
// ---------------------------------------------------------------------------------------------------------------------
self.addEventListener('message', (event) => {
    if (event.data && event.data.message) {
        debug.log(`>>> Message received from client: `, event.data);
        if (event.data.message === 'SKIP_WAITING') {
            self.skipWaiting();
        } else if (event.data.message === 'CLIENTS_CLAIM') {
            self.clients.claim();
        } else {
            debug.warning('>>>> No idea what to do with that message!');
        }
    } else {
        throw new Error(`Message event handler: event.data=[${event.data}], event.data.message=[${event.data.message}]`);
    }
});
//======================================================================================================================
// Caching
//======================================================================================================================
function deleteOldCaches(activationEvent) {
    activationEvent.waitUntil(
        caches
            .keys()
            .then(keys => keys.filter(key => key.startsWith(APP_CACHE_PREFIX) && !key.endsWith(APP_CACHE_SUFFIX)))
            .then(keys => Promise.all(keys.map(key => caches.delete(key))))
    );
}
// This file constains the stuff we need to do runtime media caching.
importScripts('/js/workbox-utils.js');
// Leverage Workbox injectManifest to give us a list of media files with revision data.
const mediaFileInfo = new WorkboxCacheFileInfo(self._MEDIA_FILES);
self.addEventListener('activate', function(event) {
    debug.log(`Lifecycle event: [${event.type}] - ready to handle fetches!`);
    deleteOldCaches(event);
    //
    WbUtils.deleteOrphansFromCache(event, MEDIA_CACHE_NAME, mediaFileInfo);
});
// ---------------------------------------------------------------------------------------------------------------------
// Runtime Audio Caching: 'vorsprung durch technik'
// ---------------------------------------------------------------------------------------------------------------------
const mediaRouteMatcher = ({url, event}) => {
    let matches = event.request.url.match(/.*\.(mp3|m4a|mp4)$/);
    return matches;
};
// TODO add expiration plugin. https://developers.google.com/web/tools/workbox/modules/workbox-expiration
const mediaRouteHandlerCacheOnly = new workbox.strategies.CacheOnly({
    cacheName: MEDIA_CACHE_NAME,
    plugins: [
        new workbox.cacheableResponse.CacheableResponsePlugin({statuses: [200]}),
        new workbox.rangeRequests.RangeRequestsPlugin(),
    ],
    matchOptions: {
        // This is needed since our resources will have a ?_WB_REVISION=... URL param.
        ignoreSearch: true,
        // Firebase vary header caused cache match to fail for mp3 until added this.
        ignoreVary: true,
    }
});
// Register the audio router.
workbox.routing.registerRoute(
    mediaRouteMatcher,
    ({event, request}) => {
        event.respondWith((async () => {
            await WbUtils.addToCache(request.url, MEDIA_CACHE_NAME, mediaFileInfo);
            return mediaRouteHandlerCacheOnly.handle({request});
        })());
    }
);

// ---------------------------------------------------------------------------------------------------------------------
// Precache.
// ---------------------------------------------------------------------------------------------------------------------
workbox.precaching.cleanupOutdatedCaches();
workbox.precaching.precacheAndRoute(self.__WB_MANIFEST);
