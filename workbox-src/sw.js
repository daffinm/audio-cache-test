// =====================================================================================================================
// WARNING: this file was generated. Edit ./workbox-src/sw.js and then run ./build to regenerate.
// =====================================================================================================================

function swlog(message, object) {
    console.log(`[Service Worker] ${message}`, object ? object : '');
}
// Switch Workbox Versions here.
const WorkboxVersions = Object.freeze({
    V4: "4.3.1",
    V5: "5.0.0-beta.0"
});
const WORKBOX_DEBUG = true;
const WORKBOX_VERSION = WorkboxVersions.V4;
// const WORKBOX_VERSION = WorkboxVersions.V5;
importScripts(`https://storage.googleapis.com/workbox-cdn/releases/${WORKBOX_VERSION}/workbox-sw.js`);
if (workbox) {
    swlog(`Yay! Workbox ${WORKBOX_VERSION} is loaded üòÅ`);
} else {
    swlog(`Boo! Workbox ${WORKBOX_VERSION} didn't load üò¨`);
}
workbox.setConfig({debug: WORKBOX_DEBUG});
workbox.core.setCacheNameDetails({
    prefix: 'act',
    suffix: WORKBOX_VERSION,
    precache: 'install-time',
    runtime: 'run-time',
});
// The plugins we are going to need
let precachePlugins = [];
let manualCachePlugins = [];
if (WORKBOX_VERSION === WorkboxVersions.V4) {
    precachePlugins = [
        new workbox.rangeRequests.Plugin()
    ];
    manualCachePlugins = [
        new workbox.cacheableResponse.Plugin({statuses: [200]}),
        new workbox.rangeRequests.Plugin(),
    ];
} else {
    precachePlugins = [
        new workbox.rangeRequests.RangeRequestsPlugin()
    ];
    manualCachePlugins = [
        new workbox.cacheableResponse.CacheableResponsePlugin({statuses: [200]}),
        new workbox.rangeRequests.RangeRequestsPlugin(),
    ];
}
// =====================================================================================================================
// 1. Precached Audio File
// =====================================================================================================================
// "If you plan on precaching the media files, then you need to take an extra step to explicitly route things so that
// they're read from the precache, since the standard precache response handler won't use the range request plugins"
workbox.routing.registerRoute(
    /.*pre-cached\.(m4a|mp3)/,
    new workbox.strategies.CacheOnly({
        cacheName: workbox.core.cacheNames.precache,
        plugins: precachePlugins,
        // This is needed since precached resources may
        // have a ?_WB_REVISION=... URL param.
        matchOptions: {
            ignoreSearch: true,
        }
    }),
);
// Precache...
workbox.precaching.precacheAndRoute([]);

// ====================================================================================================================
// 2. Manually Cached Audio File
// =====================================================================================================================
const audioCacheName = workbox.core.cacheNames.prefix + '-audio-' +workbox.core.cacheNames.suffix;
// This route will go against the network if there isn't a cache match,
// but it won't populate the cache at runtime.
// If there is a cache match, then it will properly serve partial responses.
workbox.routing.registerRoute(
    /.*manually-cached\.(m4a|mp3)/,
    // NOTE: using CacheFirst here tricked me into thinking that audio caching was working. But it was failing and going to the network instead...
    // new workbox.strategies.CacheFirst({
    new workbox.strategies.CacheOnly({
        cacheName: audioCacheName,
        plugins: manualCachePlugins,
    }),
);
// It's up to you to either precache or explicitly call cache.add('movie.mp4')
// to populate the cache.
caches.open(audioCacheName)
    .then(function(cache) {
        cache.add('/audio/m4a/manually-cached.m4a');
        cache.add('/audio/mp3/manually-cached.mp3');
    })
    .catch(function (error) {
        swlog('Error populating audio cache manually:', error);
    });

